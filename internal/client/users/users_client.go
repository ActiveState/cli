// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new users API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for users API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddEmail creates new email for a user

Create new email
*/
func (a *Client) AddEmail(params *AddEmailParams, authInfo runtime.ClientAuthInfoWriter) (*AddEmailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addEmail",
		Method:             "POST",
		PathPattern:        "/users/{username}/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddEmailOK), nil

}

/*
AddUser creates a new user

Create a new user
*/
func (a *Client) AddUser(params *AddUserParams) (*AddUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addUser",
		Method:             "POST",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddUserReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddUserOK), nil

}

/*
DeleteEmail deletes email for a user

Delete email
*/
func (a *Client) DeleteEmail(params *DeleteEmailParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteEmailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteEmail",
		Method:             "DELETE",
		PathPattern:        "/users/{username}/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteEmailOK), nil

}

/*
DeleteUser deletes a user

Delete a user
*/
func (a *Client) DeleteUser(params *DeleteUserParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteUser",
		Method:             "DELETE",
		PathPattern:        "/users/{username}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteUserOK), nil

}

/*
EditUser edits a user

Edit a user record
*/
func (a *Client) EditUser(params *EditUserParams, authInfo runtime.ClientAuthInfoWriter) (*EditUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEditUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "editUser",
		Method:             "POST",
		PathPattern:        "/users/{username}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &EditUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EditUserOK), nil

}

/*
GetEmailsByUser retrieves a user s emails

Return a list of emails matching username
*/
func (a *Client) GetEmailsByUser(params *GetEmailsByUserParams, authInfo runtime.ClientAuthInfoWriter) (*GetEmailsByUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEmailsByUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEmailsByUser",
		Method:             "GET",
		PathPattern:        "/users/{username}/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEmailsByUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEmailsByUserOK), nil

}

/*
GetUser retrieves a user record

Return a specific user matching username
*/
func (a *Client) GetUser(params *GetUserParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUser",
		Method:             "GET",
		PathPattern:        "/users/{username}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserOK), nil

}

/*
ListInvitations lists of pending invitations for an email address

Has this email address been invited to any orginzations
*/
func (a *Client) ListInvitations(params *ListInvitationsParams, authInfo runtime.ClientAuthInfoWriter) (*ListInvitationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListInvitationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listInvitations",
		Method:             "GET",
		PathPattern:        "/invitations/{email}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListInvitationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListInvitationsOK), nil

}

/*
ListUsers lists of visible users

Retrieve all users from the system that the user has access to
*/
func (a *Client) ListUsers(params *ListUsersParams, authInfo runtime.ClientAuthInfoWriter) (*ListUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listUsers",
		Method:             "GET",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListUsersOK), nil

}

/*
SendEmailVerification sends a verification email to user

Send a verification email to user
*/
func (a *Client) SendEmailVerification(params *SendEmailVerificationParams, authInfo runtime.ClientAuthInfoWriter) (*SendEmailVerificationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendEmailVerificationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendEmailVerification",
		Method:             "POST",
		PathPattern:        "/users/{username}/emails/{email}/verification/send",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SendEmailVerificationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SendEmailVerificationOK), nil

}

/*
SetPreferredEmail updates preferred email

Update preferred email
*/
func (a *Client) SetPreferredEmail(params *SetPreferredEmailParams, authInfo runtime.ClientAuthInfoWriter) (*SetPreferredEmailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetPreferredEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setPreferredEmail",
		Method:             "PATCH",
		PathPattern:        "/users/{username}/emails/{email}/preferred",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetPreferredEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetPreferredEmailOK), nil

}

/*
UniqueUsername checks if a username is already taken in the system

Is the supplied username already assigned
*/
func (a *Client) UniqueUsername(params *UniqueUsernameParams) (*UniqueUsernameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUniqueUsernameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "uniqueUsername",
		Method:             "GET",
		PathPattern:        "/users/uniqueUsername/{username}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UniqueUsernameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UniqueUsernameOK), nil

}

/*
VerifyEmail verifies the designated email

Verify the designated email
*/
func (a *Client) VerifyEmail(params *VerifyEmailParams, authInfo runtime.ClientAuthInfoWriter) (*VerifyEmailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVerifyEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "verifyEmail",
		Method:             "POST",
		PathPattern:        "/users/{username}/emails/{email}/verification/check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VerifyEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VerifyEmailOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
