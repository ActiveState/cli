package raw

import (
	"github.com/ActiveState/cli/internal/errs"
	"github.com/go-openapi/strfmt"
)

type walkFunc func(WalkNodeContext) error

// WalkNodes walks the graph and reports on nodes it encounters
// Note that the same node can be encountered multiple times if it is referenced in the graph multiple times.
// In this case the context around the node may be different, even if the node itself isn't.
func (b *Build) WalkNodes(nodeIDs []strfmt.UUID, walk walkFunc) error {
	lookup := make(map[strfmt.UUID]interface{})

	for _, artifact := range b.Artifacts {
		lookup[artifact.NodeID] = artifact
	}
	for _, step := range b.Steps {
		lookup[step.StepID] = step
	}
	for _, source := range b.Sources {
		lookup[source.NodeID] = source
	}

	for _, nodeID := range nodeIDs {
		node, ok := lookup[nodeID]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", nodeID)
		}
		if err := walkNode(WalkNodeContext{
			Node:           node,
			ParentArtifact: nil,
			Lookup:         lookup,
		}, walk); err != nil {
			return errs.Wrap(err, "could not recurse over node IDs")
		}
	}

	return nil
}

type WalkNodeContext struct {
	Node                interface{}
	ParentArtifact      *Artifact
	Lookup              map[strfmt.UUID]interface{}
	IsBuildDependency   bool // Whether we are in a build closure
	IsRuntimeDependency bool // Whether we are in a runtime closure
}

func walkNode(w WalkNodeContext, walk walkFunc) error {
	if err := walk(w); err != nil {
		return errs.Wrap(err, "error walking over node")
	}

	source, ok := w.Node.(*Source)
	if ok {
		return nil // Sources are at the end of the recursion.
	}

	ar, ok := w.Node.(*Artifact)
	if !ok {
		return errs.New("node ID '%v' is not an artifact", w.Node)
	}

	// Walk the runtime closure
	for _, id := range ar.RuntimeDependencies {
		node, ok := w.Lookup[id]
		if !ok {
			return errs.New("runtime node ID '%s' does not exist in lookup table", id)
		}

		if err := walkNode(WalkNodeContext{
			Node:                node,
			ParentArtifact:      ar,
			IsBuildDependency:   w.IsBuildDependency,
			IsRuntimeDependency: true,
			Lookup:              w.Lookup,
		}, walk); err != nil {
			return errs.Wrap(err, "error iterating over runtime dependency %s", id)
		}
	}

	// Walk the build and source closure
	generatedByNode, ok := w.Lookup[ar.GeneratedBy]
	if !ok {
		return errs.New("generated by node ID '%s' does not exist in lookup table", ar.GeneratedBy)
	}

	// Sources can also be referenced by the generatedBy property
	source, ok = generatedByNode.(*Source)
	if ok {
		if err := walk(WalkNodeContext{
			Node:                source,
			ParentArtifact:      ar,
			IsBuildDependency:   w.IsBuildDependency,
			IsRuntimeDependency: w.IsRuntimeDependency,
			Lookup:              w.Lookup,
		}); err != nil {
			return errs.Wrap(err, "error walking over source")
		}
		return nil // Sources are at the end of the recursion.
	}

	step, ok := generatedByNode.(*Step)
	if !ok {
		return errs.New("node ID '%s' has unexpected type '%T'", ar.GeneratedBy, generatedByNode)
	}

	for _, input := range step.Inputs {
		if input.Tag != TagSource && input.Tag != TagDependency {
			continue
		}
		for _, id := range input.NodeIDs {
			subNode, ok := w.Lookup[id]
			if !ok {
				return errs.New("node ID '%s' does not exist in lookup table", id)
			}
			if err := walkNode(WalkNodeContext{
				Node:                subNode,
				ParentArtifact:      ar,
				IsBuildDependency:   w.IsBuildDependency || input.Tag == TagDependency,
				IsRuntimeDependency: w.IsRuntimeDependency,
				Lookup:              w.Lookup,
			}, walk); err != nil {
				return errs.Wrap(err, "error iterating over %s", id)
			}
		}
	}

	return nil
}
