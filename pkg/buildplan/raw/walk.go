package raw

import (
	"github.com/ActiveState/cli/internal/errs"
	"github.com/ActiveState/cli/internal/logging"
	"github.com/ActiveState/cli/pkg/platform/api/buildplanner/types"
	"github.com/go-openapi/strfmt"
)

type walkFunc func(node interface{}, parent *Artifact) error

type WalkNodeContext struct {
	Node           interface{}
	ParentArtifact *Artifact
	tag            StepInputTag
	lookup         map[strfmt.UUID]interface{}
}

// WalkViaSteps walks the graph and reports on nodes it encounters
// Note that the same node can be encountered multiple times if it is referenced in the graph multiple times.
// In this case the context around the node may be different, even if the node itself isn't.
func (b *Build) WalkViaSteps(nodeIDs []strfmt.UUID, inputTag StepInputTag, walk walkFunc) error {
	lookup := b.LookupMap()

	for _, nodeID := range nodeIDs {
		node, ok := lookup[nodeID]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", nodeID)
		}
		if err := b.walkNodeViaSteps(node, nil, inputTag, walk); err != nil {
			return errs.Wrap(err, "could not recurse over node IDs")
		}
	}

	return nil
}

func (b *Build) walkNodeViaSteps(node interface{}, parent *Artifact, tag StepInputTag, walk walkFunc) error {
	lookup := b.LookupMap()

	if err := walk(node, parent); err != nil {
		return errs.Wrap(err, "error walking over node")
	}

	_, isSource := node.(*Source)
	if isSource {
		return nil // Sources are at the end of the recursion.
	}

	ar, isArtifact := node.(*Artifact)
	if !isArtifact {
		return errs.New("node ID '%v' is not an artifact", node)
	}

	// Walk the build and source closure
	generatedByNode, hasGeneratedBynode := lookup[ar.GeneratedBy]
	if !hasGeneratedBynode {
		return errs.New("generated by node ID '%s' does not exist in lookup table", ar.GeneratedBy)
	}

	// Sources can also be referenced by the generatedBy property, though this is considered an antipattern and
	// at the time of writing is only used as a workaround for builders. In theory we should never hit this in the state
	// tool, but it's technically possible to happen if someone requested a builder as part of their order.
	_, isSource = generatedByNode.(*Source)
	if isSource {
		if err := b.walkNodeViaSteps(generatedByNode, ar, tag, walk); err != nil {
			return errs.Wrap(err, "error walking source from generatedBy")
		}
		return nil // Sources are at the end of the recursion.
	}

	nodeIDs, err := b.inputNodeIDsFromStep(ar, tag)
	if err != nil {
		return errs.Wrap(err, "error walking over step inputs")
	}

	for _, id := range nodeIDs {
		// Grab subnode that we want to iterate over next
		subNode, ok := lookup[id]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", id)
		}
		if err := b.walkNodeViaSteps(subNode, ar, tag, walk); err != nil {
			return errs.Wrap(err, "error iterating over %s", id)
		}
	}

	return nil
}

// inputNodeIDsFromStep will look up all input node IDs for the given artifacts associated step (calculated from its generatedBy property)
func (b *Build) inputNodeIDsFromStep(ar *Artifact, tag StepInputTag) ([]strfmt.UUID, error) {
	lookup := b.LookupMap()

	// Walk the build and source closure
	generatedByNode, hasGeneratedBynode := lookup[ar.GeneratedBy]
	if !hasGeneratedBynode {
		return nil, errs.New("generated by node ID '%s' does not exist in lookup table", ar.GeneratedBy)
	}

	step, isStep := generatedByNode.(*Step)
	if !isStep {
		return nil, errs.New("node ID '%s' has unexpected type '%T'", ar.GeneratedBy, generatedByNode)
	}

	for _, input := range step.Inputs {
		if input.Tag != string(tag) {
			continue
		}
		return input.NodeIDs, nil
	}

	return []strfmt.UUID{}, nil
}

func (b *Build) WalkViaRuntimeDeps(nodeIDs []strfmt.UUID, walk walkFunc) error {
	lookup := b.LookupMap()

	for _, id := range nodeIDs {
		node, ok := lookup[id]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", id)
		}

		if err := b.walkNodeViaRuntimeDeps(node, nil, walk); err != nil {
			return errs.Wrap(err, "error walking over runtime dep %s", id)
		}
	}

	return nil
}

func (b *Build) walkNodeViaRuntimeDeps(node interface{}, parent *Artifact, walk walkFunc) error {
	lookup := b.LookupMap()

	ar, ok := node.(*Artifact)
	if !ok {
		// Technically this should never happen, but because we allow evaluating any part of a buildscript we can
		// encounter scenarios where we have top level sources. In this case we can simply skip them, because the
		// remaining top level nodes still cover our use-cases.
		logging.Debug("node '%#v' is not an artifact, skipping", node)
		return nil
	}

	// Only state tool artifacts are considered to be a runtime dependency
	if IsStateToolMimeType(ar.MimeType) {
		if err := walk(ar, parent); err != nil {
			return errs.Wrap(err, "error walking over runtime dep %+v", node)
		}
	}

	// Certain artifacts such as docker images and installers do not set the runtimeDependencies, instead for those
	// we need to look at the source input step.
	if len(ar.RuntimeDependencies) == 0 && !IsStateToolMimeType(ar.MimeType) {
		nodeIDs, err := b.inputNodeIDsFromStep(ar, TagSource)
		if err != nil {
			return errs.Wrap(err, "error walking over step inputs")
		}
		for _, id := range nodeIDs {
			// Grab subnode that we want to iterate over next
			subNode, ok := lookup[id]
			if !ok {
				return errs.New("step node ID '%s' does not exist in lookup table", id)
			}
			if err := b.walkNodeViaRuntimeDeps(subNode, ar, walk); err != nil {
				return errs.Wrap(err, "error walking over runtime dep %s", id)
			}
		}
	} else { // this else serves no purpose other than to make this code easier to grok; ie. this OR that is happening.
		for _, id := range ar.RuntimeDependencies {
			subNode, ok := lookup[id]
			if !ok {
				return errs.New("node ID '%s' does not exist in lookup table", id)
			}
			if err := b.walkNodeViaRuntimeDeps(subNode, ar, walk); err != nil {
				return errs.Wrap(err, "error walking over runtime dep %s", id)
			}
		}
	}

	return nil
}

func (b *Build) LookupMap() map[strfmt.UUID]interface{} {
	if b.lookup != nil {
		return b.lookup
	}

	b.lookup = make(map[strfmt.UUID]interface{})

	for _, artifact := range b.Artifacts {
		b.lookup[artifact.NodeID] = artifact
	}
	for _, step := range b.Steps {
		b.lookup[step.StepID] = step
	}
	for _, source := range b.Sources {
		b.lookup[source.NodeID] = source
	}

	return b.lookup
}

func IsStateToolMimeType(mimetype string) bool {
	return mimetype == types.XArtifactMimeType ||
		mimetype == types.XActiveStateArtifactMimeType ||
		mimetype == types.XCamelInstallerMimeType
}
