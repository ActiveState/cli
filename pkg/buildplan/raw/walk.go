package raw

import (
	"github.com/go-openapi/strfmt"

	"github.com/ActiveState/cli/internal/errs"
	"github.com/ActiveState/cli/pkg/platform/api/buildplanner/types"
)

type walkFunc func(node interface{}, parent *Artifact) error

type WalkStrategy struct {
	tag               StepInputTag
	stopAtMultiSource bool // If true, we will stop walking if the artifact relates to multiple sources (eg. installer, docker img)
}

var (
	WalkViaSingleSource = WalkStrategy{
		TagSource,
		true,
	}
	WalkViaMultiSource = WalkStrategy{
		TagSource,
		false,
	}
	WalkViaDeps = WalkStrategy{
		TagDependency,
		false,
	}
)

// WalkViaSteps walks the graph and reports on nodes it encounters
// Note that the same node can be encountered multiple times if it is referenced in the graph multiple times.
// In this case the context around the node may be different, even if the node itself isn't.
func (b *Build) WalkViaSteps(nodeIDs []strfmt.UUID, strategy WalkStrategy, walk walkFunc) error {
	lookup := b.LookupMap()

	for _, nodeID := range nodeIDs {
		node, ok := lookup[nodeID]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", nodeID)
		}
		if err := b.walkNodeViaSteps(node, nil, strategy, walk); err != nil {
			return errs.Wrap(err, "could not recurse over node IDs")
		}
	}

	return nil
}

func (b *Build) walkNodeViaSteps(node interface{}, parent *Artifact, strategy WalkStrategy, walk walkFunc) error {
	lookup := b.LookupMap()

	if err := walk(node, parent); err != nil {
		return errs.Wrap(err, "error walking over node")
	}

	_, isSource := node.(*Source)
	if isSource {
		return nil // Sources are at the end of the recursion.
	}

	ar, isArtifact := node.(*Artifact)
	if !isArtifact {
		return errs.New("node ID '%v' is not an artifact", node)
	}

	// Walk the build and source closure
	generatedByNode, hasGeneratedByNode := lookup[ar.GeneratedBy]
	if !hasGeneratedByNode {
		return errs.New("generated by node ID '%s' does not exist in lookup table", ar.GeneratedBy)
	}

	// Sources can also be referenced by the generatedBy property, though this is considered an antipattern and
	// at the time of writing is only used as a workaround for builders. In theory we should never hit this in the state
	// tool, but it's technically possible to happen if someone requested a builder as part of their order.
	_, isSource = generatedByNode.(*Source)
	if isSource {
		if err := b.walkNodeViaSteps(generatedByNode, ar, strategy, walk); err != nil {
			return errs.Wrap(err, "error walking source from generatedBy")
		}
		return nil // Sources are at the end of the recursion.
	}

	nodeIDs, err := b.inputNodeIDsFromStep(ar, strategy.tag)
	if err != nil {
		return errs.Wrap(err, "error walking over step inputs")
	}

	// Stop if the next step has multiple input node ID's; this means we cannot determine a single source
	if strategy.stopAtMultiSource && len(nodeIDs) > 1 {
		return nil
	}

	for _, id := range nodeIDs {
		// Grab subnode that we want to iterate over next
		subNode, ok := lookup[id]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", id)
		}
		if err := b.walkNodeViaSteps(subNode, ar, strategy, walk); err != nil {
			return errs.Wrap(err, "error iterating over %s", id)
		}
	}

	return nil
}

// inputNodeIDsFromStep will look up all input node IDs for the given artifacts associated step (calculated from its generatedBy property)
func (b *Build) inputNodeIDsFromStep(ar *Artifact, tag StepInputTag) ([]strfmt.UUID, error) {
	lookup := b.LookupMap()

	// Walk the build and source closure
	generatedByNode, hasGeneratedByNode := lookup[ar.GeneratedBy]
	if !hasGeneratedByNode {
		return nil, errs.New("generated by node ID '%s' does not exist in lookup table", ar.GeneratedBy)
	}

	// If this refers to a source step then we have nothing to do
	if _, isSource := generatedByNode.(*Source); isSource {
		return []strfmt.UUID{}, nil
	}

	step, isStep := generatedByNode.(*Step)
	if !isStep {
		return nil, errs.New("node ID '%s' has unexpected type '%T'", ar.GeneratedBy, generatedByNode)
	}

	for _, input := range step.Inputs {
		if input.Tag != string(tag) {
			continue
		}
		return input.NodeIDs, nil
	}

	return []strfmt.UUID{}, nil
}

func (b *Build) WalkViaRuntimeDeps(nodeIDs []strfmt.UUID, walk walkFunc) error {
	lookup := b.LookupMap()
	visited := make(map[strfmt.UUID]bool)

	for _, id := range nodeIDs {
		node, ok := lookup[id]
		if !ok {
			return errs.New("node ID '%s' does not exist in lookup table", id)
		}

		if err := b.walkNodeViaRuntimeDeps(node, nil, visited, walk); err != nil {
			return errs.Wrap(err, "error walking over runtime dep %s", id)
		}
	}

	return nil
}

func (b *Build) walkNodeViaRuntimeDeps(node interface{}, parent *Artifact, visited map[strfmt.UUID]bool, walk walkFunc) error {
	lookup := b.LookupMap()

	ar, ok := node.(*Artifact)
	if !ok {
		// This can only happen in two scenarios that we're aware of:
		// 1. Because we allow evaluating any part of a buildscript we can encounter scenarios where we have top level
		// sources.
		// 2. We are dealing with an old camel build.
		// In these cases we can simply skip them, because the remaining top level nodes still cover our use-cases.
		return nil
	}

	// If we detect a cycle we should stop
	if visited[ar.NodeID] {
		return nil
	}
	visited[ar.NodeID] = true

	// Only state tool artifacts are considered to be a runtime dependency
	if IsStateToolMimeType(ar.MimeType) {
		if err := walk(ar, parent); err != nil {
			return errs.Wrap(err, "error walking over runtime dep %+v", node)
		}
	}

	// Certain artifacts such as docker images and installers do not set the runtimeDependencies, instead for those
	// we need to look at the source input step.
	if len(ar.RuntimeDependencies) == 0 && !IsStateToolMimeType(ar.MimeType) {
		nodeIDs, err := b.inputNodeIDsFromStep(ar, TagSource)
		if err != nil {
			return errs.Wrap(err, "error walking over step inputs")
		}
		for _, id := range nodeIDs {
			// Grab subnode that we want to iterate over next
			subNode, ok := lookup[id]
			if !ok {
				return errs.New("step node ID '%s' does not exist in lookup table", id)
			}
			if err := b.walkNodeViaRuntimeDeps(subNode, ar, visited, walk); err != nil {
				return errs.Wrap(err, "error walking over runtime dep %s", id)
			}
		}
	} else { // this else serves no purpose other than to make this code easier to grok; ie. this OR that is happening.
		for _, id := range ar.RuntimeDependencies {
			subNode, ok := lookup[id]
			if !ok {
				return errs.New("node ID '%s' does not exist in lookup table", id)
			}
			if err := b.walkNodeViaRuntimeDeps(subNode, ar, visited, walk); err != nil {
				return errs.Wrap(err, "error walking over runtime dep %s", id)
			}
		}
	}

	return nil
}

func (b *Build) LookupMap() map[strfmt.UUID]interface{} {
	if b.lookup != nil {
		return b.lookup
	}

	b.lookup = make(map[strfmt.UUID]interface{})

	for _, artifact := range b.Artifacts {
		b.lookup[artifact.NodeID] = artifact
	}
	for _, step := range b.Steps {
		b.lookup[step.StepID] = step
	}
	for _, source := range b.Sources {
		b.lookup[source.NodeID] = source
	}

	return b.lookup
}

func IsStateToolMimeType(mimetype string) bool {
	return mimetype == types.XArtifactMimeType ||
		mimetype == types.XActiveStateArtifactMimeType ||
		mimetype == types.XCamelInstallerMimeType
}
