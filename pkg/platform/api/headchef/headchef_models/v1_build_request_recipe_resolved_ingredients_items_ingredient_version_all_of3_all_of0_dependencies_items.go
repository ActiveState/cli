// Code generated by go-swagger; DO NOT EDIT.

package headchef_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems Dependency
//
// A single dependency for an ingredient version revision
// swagger:model v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems
type V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems struct {

	// The features that must already be present in the recipe for this requirement to apply. For example, can be used to create requirements that only apply on specific operating systems.
	Conditions []*V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsConditionsItems `json:"conditions"`

	// A description of this dependency
	Description string `json:"description,omitempty"`

	// The name of the feature this ingredient version is dependent on
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the feature depended on is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Whatever text or data structure we parsed to generate this dependency
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Requirements
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsRequirementsItems `json:"requirements"`

	// Recipe
	//
	// The different types of dependencies supported by the platform.
	// Required: true
	// Enum: [build runtime test]
	Type *string `json:"type"`
}

// Validate validates this v1 build request recipe resolved ingredients items ingredient version all of3 all of0 dependencies items
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTypePropEnum = append(v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTypePropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeBuild captures enum value "build"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeBuild string = "build"

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeRuntime captures enum value "runtime"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeRuntime string = "runtime"

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTest captures enum value "test"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTest string = "test"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItemsTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3AllOf0DependenciesItems
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
