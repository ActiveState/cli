// Code generated by go-swagger; DO NOT EDIT.

package headchef_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems Dependency
//
// A single dependency for an ingredient version revision
// swagger:model v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems
type V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems struct {

	// The features that must already be present in the recipe for this requirement to apply. For example, can be used to create requirements that only apply on specific operating systems.
	Conditions []*V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsConditionsItems `json:"conditions"`

	// A description of this dependency
	Description string `json:"description,omitempty"`

	// The name of the feature this ingredient version is dependent on
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the feature depended on is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Whatever text or data structure we parsed to generate this dependency
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Requirements
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Items: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsRequirementsItems `json:"requirements"`

	// Dependency type
	//
	// The different types of dependencies supported by the platform.
	// Required: true
	// Enum: [build runtime test]
	Type string `json:"type"`
}

// Validate validates this v1 build request recipe resolved ingredients items ingredient version all of3 dependencies items
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	iRequirementsSize := int64(len(m.Requirements))

	if err := validate.MinItems("requirements", "body", iRequirementsSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTypePropEnum = append(v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTypePropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeBuild captures enum value "build"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeBuild string = "build"

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeRuntime captures enum value "runtime"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeRuntime string = "runtime"

	// V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTest captures enum value "test"
	V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTest string = "test"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItemsTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) validateType(formats strfmt.Registry) error {

	if err := validate.RequiredString("type", "body", string(m.Type)); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItemsIngredientVersionAllOf3DependenciesItems
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
