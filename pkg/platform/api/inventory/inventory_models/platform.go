// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Platform Platform
//
// A platform upon which a build can be built.
//
// swagger:model platform
type Platform struct {

	// cpu architecture
	// Required: true
	CPUArchitecture *CPUArchitecture `json:"cpu_architecture"`

	// cpu extensions
	CPUExtensions []*CPUExtension `json:"cpu_extensions"`

	// The date and time this platform was created.
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// display name
	// Required: true
	DisplayName *string `json:"display_name"`

	// The last day on which this platform will be supported. Can be omitted if no last day has yet been determined.
	// Format: date
	EndOfSupportDate *strfmt.Date `json:"end_of_support_date,omitempty"`

	// gpu architecture
	GpuArchitecture *GpuArchitecture `json:"gpu_architecture,omitempty"`

	// images
	// Required: true
	Images []*Image `json:"images"`

	// If true, the platform should be shown to the user as a selectable platform for an order. If false, the platform should be hidden from the user.
	IsUserVisible *bool `json:"is_user_visible,omitempty"`

	// kernel
	// Required: true
	Kernel *Kernel `json:"kernel"`

	// kernel version
	// Required: true
	KernelVersion *KernelVersion `json:"kernel_version"`

	// libc
	Libc *Libc `json:"libc,omitempty"`

	// libc version
	LibcVersion *LibcVersion `json:"libc_version,omitempty"`

	// links
	// Required: true
	Links *SelfLink `json:"links"`

	// operating system
	// Required: true
	OperatingSystem *OperatingSystem `json:"operating_system"`

	// operating system version
	// Required: true
	OperatingSystemVersion *OperatingSystemVersion `json:"operating_system_version"`

	// platform id
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`
}

// Validate validates this platform
func (m *Platform) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPUExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndOfSupportDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernelVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibcVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystemVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Platform) validateCPUArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("cpu_architecture", "body", m.CPUArchitecture); err != nil {
		return err
	}

	if m.CPUArchitecture != nil {
		if err := m.CPUArchitecture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cpu_architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateCPUExtensions(formats strfmt.Registry) error {
	if swag.IsZero(m.CPUExtensions) { // not required
		return nil
	}

	for i := 0; i < len(m.CPUExtensions); i++ {
		if swag.IsZero(m.CPUExtensions[i]) { // not required
			continue
		}

		if m.CPUExtensions[i] != nil {
			if err := m.CPUExtensions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cpu_extensions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Platform) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Platform) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("display_name", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *Platform) validateEndOfSupportDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndOfSupportDate) { // not required
		return nil
	}

	if err := validate.FormatOf("end_of_support_date", "body", "date", m.EndOfSupportDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Platform) validateGpuArchitecture(formats strfmt.Registry) error {
	if swag.IsZero(m.GpuArchitecture) { // not required
		return nil
	}

	if m.GpuArchitecture != nil {
		if err := m.GpuArchitecture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gpu_architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateImages(formats strfmt.Registry) error {

	if err := validate.Required("images", "body", m.Images); err != nil {
		return err
	}

	for i := 0; i < len(m.Images); i++ {
		if swag.IsZero(m.Images[i]) { // not required
			continue
		}

		if m.Images[i] != nil {
			if err := m.Images[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Platform) validateKernel(formats strfmt.Registry) error {

	if err := validate.Required("kernel", "body", m.Kernel); err != nil {
		return err
	}

	if m.Kernel != nil {
		if err := m.Kernel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateKernelVersion(formats strfmt.Registry) error {

	if err := validate.Required("kernel_version", "body", m.KernelVersion); err != nil {
		return err
	}

	if m.KernelVersion != nil {
		if err := m.KernelVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel_version")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateLibc(formats strfmt.Registry) error {
	if swag.IsZero(m.Libc) { // not required
		return nil
	}

	if m.Libc != nil {
		if err := m.Libc.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateLibcVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.LibcVersion) { // not required
		return nil
	}

	if m.LibcVersion != nil {
		if err := m.LibcVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc_version")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateOperatingSystem(formats strfmt.Registry) error {

	if err := validate.Required("operating_system", "body", m.OperatingSystem); err != nil {
		return err
	}

	if m.OperatingSystem != nil {
		if err := m.OperatingSystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validateOperatingSystemVersion(formats strfmt.Registry) error {

	if err := validate.Required("operating_system_version", "body", m.OperatingSystemVersion); err != nil {
		return err
	}

	if m.OperatingSystemVersion != nil {
		if err := m.OperatingSystemVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system_version")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this platform based on the context it is used
func (m *Platform) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCPUArchitecture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCPUExtensions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGpuArchitecture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKernel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKernelVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLibc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLibcVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOperatingSystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOperatingSystemVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Platform) contextValidateCPUArchitecture(ctx context.Context, formats strfmt.Registry) error {

	if m.CPUArchitecture != nil {
		if err := m.CPUArchitecture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cpu_architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateCPUExtensions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CPUExtensions); i++ {

		if m.CPUExtensions[i] != nil {
			if err := m.CPUExtensions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cpu_extensions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Platform) contextValidateGpuArchitecture(ctx context.Context, formats strfmt.Registry) error {

	if m.GpuArchitecture != nil {
		if err := m.GpuArchitecture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gpu_architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateImages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Images); i++ {

		if m.Images[i] != nil {
			if err := m.Images[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Platform) contextValidateKernel(ctx context.Context, formats strfmt.Registry) error {

	if m.Kernel != nil {
		if err := m.Kernel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateKernelVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.KernelVersion != nil {
		if err := m.KernelVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel_version")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateLibc(ctx context.Context, formats strfmt.Registry) error {

	if m.Libc != nil {
		if err := m.Libc.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateLibcVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.LibcVersion != nil {
		if err := m.LibcVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc_version")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateOperatingSystem(ctx context.Context, formats strfmt.Registry) error {

	if m.OperatingSystem != nil {
		if err := m.OperatingSystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system")
			}
			return err
		}
	}

	return nil
}

func (m *Platform) contextValidateOperatingSystemVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.OperatingSystemVersion != nil {
		if err := m.OperatingSystemVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system_version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Platform) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Platform) UnmarshalBinary(b []byte) error {
	var res Platform
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
