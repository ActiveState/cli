package buildplan

import (
	"fmt"

	"github.com/go-openapi/strfmt"

	"github.com/ActiveState/cli/internal/errs"
	"github.com/ActiveState/cli/pkg/platform/api/buildplanner/model"
	"github.com/ActiveState/cli/pkg/platform/runtime/artifact"
)

// buildRuntimeDependencies is a recursive function that builds up a map of runtime dependencies
// for an artifact. It expects the ID of an artifact and a lookup table that contains all of the
// artifacts in the build plan. It will recursively call itself with each of the artifact's
// dependencies and add them to the result map.
func buildRuntimeDependencies(depdendencyID strfmt.UUID, lookup map[strfmt.UUID]interface{}, result map[strfmt.UUID]struct{}) (map[strfmt.UUID]struct{}, error) {
	artifact, ok := lookup[depdendencyID].(*model.Artifact)
	if !ok {
		return nil, errs.New("Incorrect target type for id %s, expected Artifact", depdendencyID)
	}

	for _, depID := range artifact.RuntimeDependencies {
		result[depID] = struct{}{}
		_, err := buildRuntimeDependencies(depID, lookup, result)
		if err != nil {
			return nil, errs.Wrap(err, "Could not build map for runtime dependencies of artifact %s", artifact.NodeID)
		}
	}

	return result, nil
}

// buildBuildClosureDependencies is a recursive function that builds up a map
// of build-time dependencies for a given artifact if it is not already present
// in the results map. It first iterates through the runtime dependencies of the
// artifact recursively adding all of the dependencies to the results map.
// Then it iterates through the inputs of the step that generated the
// artifact and recursively adds all of those dependencies as well.
func buildBuildClosureDependencies(artifactID strfmt.UUID, lookup map[strfmt.UUID]interface{}, deps map[strfmt.UUID]struct{}, result artifact.Map) (map[strfmt.UUID]struct{}, error) {
	if _, ok := result[artifactID]; ok {
		// We have already processed this artifact, skipping
		return nil, nil
	}

	currentArtifact, ok := lookup[artifactID].(*model.Artifact)
	if !ok {
		return nil, errs.New("Incorrect target type for id %s, expected Artifact", artifactID)
	}

	// We iterate through the direct dependencies of the artifact
	// and recursively add all of the dependencies of those artifacts map.
	// This is the same as the runtime closure calculation.
	for _, depID := range currentArtifact.RuntimeDependencies {
		deps[depID] = struct{}{}
		artifactDeps := make(map[strfmt.UUID]struct{})
		_, err := buildBuildClosureDependencies(depID, lookup, artifactDeps, result)
		if err != nil {
			return nil, errs.Wrap(err, "Could not build map for runtime dependencies of artifact %s", currentArtifact.NodeID)
		}
	}

	// Here we iterate through the inputs of the step that generated the
	// artifact, specifically the inputs that are tagged as dependencies.
	// We recursively add all of the dependencies of the step intputs to
	// the result map. This is the buildtime closure calculation.
	step, ok := lookup[currentArtifact.GeneratedBy].(*model.Step)
	if !ok {
		// Artifact was not generated by a step, skipping because these
		// artifacts do not need to be built.
		return nil, nil
	}

	// We iterate through the inputs of the step that generated the
	// artifact, specifically the inputs that are tagged as dependencies and
	// build a build-time closure for each.
	for _, input := range step.Inputs {
		if input.Tag != model.TagDependency {
			continue
		}

		for _, inputID := range input.NodeIDs {
			deps[inputID] = struct{}{}
			_, err := buildBuildClosureDependencies(inputID, lookup, deps, result)
			if err != nil {
				return nil, errs.Wrap(err, "Could not build map for step dependencies of artifact %s", currentArtifact.NodeID)
			}
		}
	}

	var uniqueDeps []strfmt.UUID
	for id := range deps {
		uniqueDeps = append(uniqueDeps, id)
	}

	info, err := getSourceInfo(currentArtifact.GeneratedBy, lookup)
	if err != nil {
		return nil, errs.Wrap(err, "Could not resolve source information")
	}

	result[strfmt.UUID(currentArtifact.NodeID)] = artifact.Artifact{
		ArtifactID:       strfmt.UUID(currentArtifact.NodeID),
		Name:             info.Name,
		Namespace:        info.Namespace,
		Version:          &info.Version,
		RequestedByOrder: true,
		GeneratedBy:      currentArtifact.GeneratedBy,
		Dependencies:     uniqueDeps,
		URL:              currentArtifact.URL,
	}

	return deps, nil
}

// DependencyTreeFor returns for the given artifact ID a map of dependencies to a list of unique
// subdependencies. The returned map excludes any dependencies in the given filter, unless there is
// a version mismatch and `keepUpdated` is true (this signifies a dependency's version was
// updated).
func DependencyTreeFor(a artifact.ArtifactID, artifacts artifact.Map, filter artifact.Map, keepUpdated bool) map[artifact.ArtifactID][]artifact.ArtifactID {
	// Construct a lookup map to easily see if a given artifact ID should be filtered out.
	filterMap := make(map[string]string)
	for _, artifactToFilter := range filter {
		version := ""
		if artifactToFilter.Version != nil {
			version = *artifactToFilter.Version
		}
		filterMap[fmt.Sprintf("%s/%s", artifactToFilter.Namespace, artifactToFilter.Name)] = version
	}

	// Closure that returns whether or not to include a given artifact ID in the dependency tree.
	include := func(depId artifact.ArtifactID) bool {
		dep := artifacts[depId]
		oldVersion, exists := filterMap[fmt.Sprintf("%s/%s", dep.Namespace, dep.Name)]
		return !exists || (keepUpdated && dep.Version != nil && oldVersion != *dep.Version)
	}

	// Construct and return the dependency tree.
	dependencies := make(map[artifact.ArtifactID][]artifact.ArtifactID)
	for _, artifactId := range dependenciesFor(a, artifacts, false) {
		if !include(artifactId) {
			continue
		}

		list := make([]artifact.ArtifactID, 0)
		for _, depId := range dependenciesFor(artifactId, artifacts, true) {
			if include(depId) {
				list = append(list, depId)
			}
		}
		dependencies[artifactId] = list
	}
	return dependencies
}

// RecursiveDependenciesFor computes the recursive (direct and indirect) dependencies for an
// ArtifactID a using artifacts as a lookup table
func RecursiveDependenciesFor(a artifact.ArtifactID, artifacts artifact.Map) []artifact.ArtifactID {
	return dependenciesFor(a, artifacts, true)
}

func dependenciesFor(a artifact.ArtifactID, artifacts artifact.Map, recursive bool) []artifact.ArtifactID {
	allDeps := make(map[artifact.ArtifactID]struct{})
	artf, ok := artifacts[a]
	if !ok {
		return nil
	}
	toCheck := artf.Dependencies

	for len(toCheck) > 0 {
		var newToCheck []artifact.ArtifactID
		for _, a := range toCheck {
			if _, ok := allDeps[a]; ok {
				continue
			}
			artf, ok := artifacts[a]
			if !ok {
				continue
			}
			if recursive {
				newToCheck = append(newToCheck, artf.Dependencies...)
			}
			allDeps[a] = struct{}{}
		}
		toCheck = newToCheck
	}

	res := make([]artifact.ArtifactID, 0, len(allDeps))
	for a := range allDeps {
		res = append(res, a)
	}
	return res
}
